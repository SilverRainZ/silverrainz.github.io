==================================
å‡½æ•°å¼ç¼–ç¨‹åœ¨ Go æ³›å‹ä¸‹çš„å®ç”¨æ€§æ¢ç´¢
==================================


.. post:: 2021-10-27
   :tags: Golang, æ³›å‹, å‡½æ•°å¼ç¼–ç¨‹
   :author: LA
   :language: zh_CN

.. highlight:: go

èƒŒæ™¯
====

å‡½æ•°å¼ç¼–ç¨‹ï¼ˆFunctional Programming / FPï¼‰ä½œä¸ºä¸€ç§ç¼–ç¨‹èŒƒå¼ï¼Œå…·æœ‰æ— çŠ¶æ€ã€æ— å‰¯ä½œç”¨ã€å¹¶å‘å‹å¥½ã€æŠ½è±¡ç¨‹åº¦é«˜ç­‰ä¼˜ç‚¹ã€‚ç›®å‰æµè¡Œçš„ç¼–ç¨‹è¯­è¨€ï¼ˆC++ã€Pythonã€Rustï¼‰éƒ½æˆ–å¤šæˆ–å°‘åœ°å¼•å…¥äº†å‡½æ•°å¼ç‰¹æ€§ï¼Œä½†åœ¨åŒä½œä¸ºæµè¡Œè¯­è¨€çš„ Golang ä¸­å´å°‘æœ‰è®¨è®ºã€‚

ç©¶å…¶åŸå› ï¼Œå¤§éƒ¨åˆ†çš„æŠ±æ€¨ [2]_ [3]_ é›†ä¸­äº Go ç¼ºä¹å¯¹èŒƒå‹çš„æ”¯æŒï¼Œéš¾ä»¥å†™å‡ºç±»å‹é—´é€šç”¨çš„å‡½æ•°ã€‚ä»£ç ç”Ÿæˆåªèƒ½è§£å†³ä¸€éƒ¨åˆ†å·²çŸ¥ç±»å‹çš„å¤„ç†ï¼Œä¸”æ— æ³•åº”å¯¹ç±»å‹ç»„åˆå¯¼è‡´å¤æ‚åº¦ï¼ˆæ¯”å¦‚å®ç°ä¸€ä¸ªé€šç”¨çš„ TypeA â†’ TypeB çš„ map å‡½æ•°ï¼‰ã€‚

æœ‰å…³æ³›å‹çš„ææ¡ˆ `spec: add generic programming using type parameters #43651`__ å·²ç»è¢« Go å›¢é˜Ÿæ¥å—ï¼Œå¹¶è®¡åˆ’åœ¨ 2022 å¹´åˆå‘å¸ƒæ”¯æŒèŒƒå‹çš„ Go 1.18ï¼Œç°åœ¨ golang/go ä»“åº“çš„ master åˆ†æ”¯å·²ç»æ”¯æŒèŒƒå‹ã€‚

   This design has been proposed and accepted as a future language change. We currently expect that this change will be available in the Go 1.18 release in early 2022. [1]_

åŸºäºè¿™ä¸ªé‡å¤§ç‰¹æ€§ï¼Œæˆ‘ä»¬æœ‰ç†ç”±é‡æ–°çœ‹çœ‹ï¼Œå‡½æ•°å¼ç‰¹æ€§åœ¨ Go èŒƒå‹çš„åŠ æŒä¸‹ï¼Œèƒ½å¦å˜å¾—æ¯”ä»¥å¾€æ›´åŠ å®ç”¨ã€‚

__ https://github.com/golang/go/issues/43651

æ¦‚è¿°
====

è¿™ç¯‡æ–‡ç« é‡Œï¼Œæˆ‘ä»¬ä¼šå°è¯•ç”¨ Go çš„æ³›å‹å¾ªåºæ¸è¿›åœ°å®ç°ä¸€äº›å¸¸è§çš„å‡½æ•°å¼ç‰¹æ€§ï¼Œä»è€Œæ¢ç´¢ Go æ³›å‹çš„ä¼˜åŠ¿å’Œä¸è¶³ã€‚

é™¤éé¢å¤–è¯´æ˜ï¼ˆä¾‹å¦‚æ³¨é‡Šä¸­çš„ `// INVALID CODE!!!`ï¼‰ï¼Œæ–‡ç« é‡Œçš„ä»£ç éƒ½æ˜¯å¯ä»¥è¿è¡Œçš„ï¼ˆä¸ºäº†ç¼©å‡ç¯‡å¹…ï¼Œéƒ¨åˆ†åˆ å»äº† `package main` å£°æ˜å’Œ `main` å‡½æ•°ï¼Œè¯·è‡ªè¡Œæ·»åŠ ï¼‰ã€‚ä½ å¯ä»¥è‡ªè¡Œ ä»æºç ç¼–è¯‘__ ä¸€ä¸ª master ç‰ˆæœ¬çš„ go æ¥æå‰ä½“éªŒ Go çš„æ³›å‹ï¼Œæˆ–è€…ç”¨ `The go2go Playground`__ æä¾›çš„åœ¨çº¿ç¼–è¯‘å™¨è¿è¡Œå•ä¸ªæ–‡ä»¶ã€‚

__ https://golang.org/doc/install/source#install
__ https://go2goplay.golang.org/

æ³›å‹è¯­æ³•
========

ææ¡ˆçš„ `#Very high level overview`__ ä¸€èŠ‚ä¸­æè¿°äº†ä¸ºèŒƒå‹è€Œæ·»åŠ çš„æ–°è¯­æ³•ï¼Œè¿™é‡Œç®€å•æè¿°ä¸€ä¸‹é˜…è¯»æœ¬æ–‡æ‰€éœ€è¦çš„è¯­æ³•ï¼š

- å‡½æ•°ååå¯ä»¥é™„å¸¦ä¸€ä¸ªæ–¹æ‹¬å·ï¼ŒåŒ…å«äº†è¯¥å‡½æ•°æ¶‰åŠçš„ç±»å‹å‚æ•°ï¼ˆType Paramtersï¼‰çš„åˆ—è¡¨ï¼š`func F[T any](p T) { ... }`
- è¿™äº›ç±»å‹å‚æ•°å¯ä»¥åœ¨å‡½æ•°å‚æ•°å’Œå‡½æ•°ä½“ä¸­ï¼ˆä½œä¸ºç±»å‹ï¼‰è¢«ä½¿ç”¨
- è‡ªå®šä¹‰ç±»å‹ä¹Ÿå¯ä»¥æœ‰ç±»å‹å‚æ•°åˆ—è¡¨ï¼š`type M[T any] []T`
- æ¯ä¸ªç±»å‹å‚æ•°å¯¹åº”ä¸€ä¸ªç±»å‹çº¦æŸï¼Œä¸Šè¿°çš„ `any` å°±æ˜¯é¢„å®šä¹‰çš„åŒ¹é…ä»»æ„ç±»å‹çš„çº¦æŸ
- ç±»å‹çº¦æŸåœ¨è¯­æ³•ä¸Šä»¥ `interface` çš„å½¢å¼å­˜åœ¨ï¼Œåœ¨ `interface` ä¸­åµŒå…¥ç±»å‹ `T` å¯ä»¥è¡¨ç¤ºè¿™ä¸ªç±»å‹å¿…é¡»æ˜¯ `T`::

   type Integer1 interface {
       int
   }

- åµŒå…¥å•ä¸ªç±»å‹æ„ä¹‰ä¸å¤§ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ `|` æ¥æè¿°ç±»å‹çš„ union::

   type Integer2 interface {
       int | int8 | int16 | int32 | int64
   }

- `~T` è¯­æ³•å¯ä»¥è¡¨ç¤ºè¯¥ç±»å‹çš„ã€ŒåŸºç¡€ç±»å‹ã€æ˜¯ `T`ï¼Œæ¯”å¦‚è¯´æˆ‘ä»¬çš„è‡ªå®šä¹‰ç±»å‹ `type MyInt int` ä¸æ»¡è¶³ä¸Šè¿°çš„ `Integer1` çº¦æŸï¼Œä½†æ»¡è¶³ä»¥ä¸‹çš„çº¦æŸ::

   type Integer3 interface {
       ~int
   }

.. hint:: ã€ŒåŸºç¡€ç±»å‹ã€åœ¨ææ¡ˆä¸­ä¸º "underlying type"ï¼Œç›®å‰å°šæ— æƒå¨ç¿»è¯‘ï¼Œåœ¨æœ¬æ–‡ä¸­ä½¿ç”¨ä»…ä¸ºæ–¹ä¾¿æè¿°ã€‚

__ https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#very-high-level-overview

é«˜é˜¶å‡½æ•°
========

åœ¨å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œ:zhwiki:`é«˜é˜¶å‡½æ•°` ï¼ˆHigher-order functionï¼‰æ˜¯ä¸€ä¸ªé‡è¦çš„ç‰¹æ€§ã€‚é«˜é˜¶å‡½æ•°æ˜¯è‡³å°‘æ»¡è¶³ä¸‹åˆ—ä¸€ä¸ªæ¡ä»¶çš„å‡½æ•°ï¼š 

- æ¥å—ä¸€ä¸ªæˆ–å¤šä¸ªå‡½æ•°ä½œä¸ºè¾“å…¥
- è¾“å‡ºä¸€ä¸ªå‡½æ•°

Golang æ”¯æŒé—­åŒ…ï¼Œæ‰€ä»¥å®ç°é«˜é˜¶å‡½æ•°æ¯«æ— é—®é¢˜::

   func foo(bar func() string) func() string {
           return func() string {
                   return "foo" + " " + bar()
           }
   }

   func main() {
           bar := func() string {
                   return "bar"
           }
           foobar := foo(bar)
           fmt.Println(foobar())
   }
   // Output:
   // foo bar

filter æ“ä½œæ˜¯é«˜é˜¶å‡½æ•°çš„ç»å…¸åº”ç”¨ï¼Œå®ƒæ¥å—ä¸€ä¸ªå‡½æ•° fï¼ˆ`func (T) bool`ï¼‰å’Œä¸€ä¸ªçº¿æ€§è¡¨ lï¼ˆ`[] T`ï¼‰ï¼Œå¯¹ l ä¸­çš„æ¯ä¸ªå…ƒç´ åº”ç”¨å‡½æ•° fï¼Œå¦‚ç»“æœä¸º `true`ï¼Œåˆ™å°†è¯¥å…ƒç´ åŠ å…¥æ–°çš„çº¿æ€§è¡¨é‡Œï¼Œå¦åˆ™ä¸¢å¼ƒè¯¥å…ƒç´ ï¼Œæœ€åè¿”å›æ–°çš„çº¿æ€§è¡¨ã€‚

æ ¹æ®ä¸Šé¢çš„æ³›å‹è¯­æ³•ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°å†™å‡ºä¸€ä¸ªç®€å•çš„ filter å‡½æ•°::

   func Filter[T any](f func(T) bool, src []T) []T {
           var dst []T
           for _, v := range src {
                   if f(v) {
                           dst = append(dst, v)
                   }
           }
           return dst
   }

   func main() {
           src := []int{-2, -1, -0, 1, 2}
           dst := Filter(func(v int) bool { return v >= 0 }, src)
           fmt.Println(dst)
   } 
   // Output:
   // [0 1 2]

ä»£ç ç”Ÿæˆä¹‹å›°
------------

åœ¨ 1.17 æˆ–è€…æ›´æ—©å‰çš„ Go ç‰ˆæœ¬ä¸­ï¼Œè¦å®ç°é€šç”¨çš„ Filter å‡½æ•°æœ‰ä¸¤ç§æ–¹å¼ï¼š

1. ä½¿ç”¨ `interface{}` é…åˆåå°„ï¼Œç‰ºç‰²ä¸€å®šç¨‹åº¦çš„ç±»å‹å®‰å…¨å’Œè¿è¡Œæ•ˆç‡
2. ä¸ºä¸åŒæ•°æ®ç±»å‹å®ç°ä¸åŒçš„ Filter å˜ç§ï¼Œä¾‹å¦‚ `FilterInt`ã€`FilterString` ç­‰ï¼Œç¼ºç‚¹åœ¨äºå†—ä½™åº¦é«˜ï¼Œç»´æŠ¤éš¾åº¦å¤§

æ–¹å¼ 2 çš„ç¼ºç‚¹å¯ä»¥é€šè¿‡ä»£ç ç”Ÿæˆè§„é¿ï¼Œå…·ä½“æ¥è¯´å°±ä½¿ç”¨ç›¸åŒçš„ä¸€ä»½æ¨¡ç‰ˆï¼Œä»¥æ•°æ®ç±»å‹ä¸ºå˜é‡ç”Ÿæˆä¸åŒçš„å®ç°ã€‚æˆ‘ä»¬åœ¨ Golang å†…éƒ¨å¯ä»¥çœ‹åˆ°ä¸å°‘ ä»£ç ç”Ÿæˆçš„ä¾‹å­__ ã€‚

é‚£ä¹ˆï¼Œæœ‰äº†ä»£ç ç”Ÿæˆï¼Œæˆ‘ä»¬æ˜¯ä¸æ˜¯å°±ä¸éœ€è¦æ³›å‹äº†å‘¢ï¼Ÿ

ç­”æ¡ˆæ˜¯å¦å®šçš„ï¼š

1. ä»£ç ç”Ÿæˆåªèƒ½é’ˆå¯¹å·²çŸ¥çš„ç±»å‹ç”Ÿæˆä»£ç ï¼Œæ˜æ˜è¿™ä»½æ¨¡ç‰ˆå¯¹ `float64` ä¹Ÿæœ‰æ•ˆï¼Œä½†ä½œè€…åªç”Ÿæˆäº†å¤„ç† `int` çš„ç‰ˆæœ¬ï¼Œæˆ‘ä»¬ä½œä¸ºç”¨æˆ·æ— èƒ½ä¸ºåŠ›ï¼ˆç”¨ `interface{}` åŒç†ï¼Œæˆ‘ä»¬èƒ½ä½¿ç”¨ä»€ä¹ˆç±»å‹ï¼Œå–å†³äºä½œè€…åˆ—å‡ºäº†å¤šå°‘ä¸ª type switch çš„ casesï¼‰

   è€Œåœ¨æ³›å‹é‡Œï¼Œæ–°çš„ç±»å‹çº¦æŸè¯­æ³•å¯ä»¥ç»Ÿä¸€åœ°å¤„ç†ã€ŒåŸºç¡€ç±»å‹ã€ç›¸åŒçš„æ‰€æœ‰ç±»å‹::

      type signed interface {
              ~int | ~int8 | ~int16 | ~int32 | ~int64 | ~float32 | ~float64 | ~complex64 | ~complex128
      }

      func Neg[T signed](n T) T {
              return -n
      }

      func main() {
              type MyInt int

              fmt.Println(Neg(1))
              fmt.Println(Neg(1.1))
              fmt.Println(Neg(MyInt(1)))
      } 
      // Output:
      // -1
      // -1.1
      // -1

2. ä»£ç ç”Ÿæˆéš¾ä»¥åº”å¯¹éœ€è¦ç±»å‹ç»„åˆçš„åœºæ™¯ï¼Œæˆ‘ä»¬æ¥çœ‹å¦ä¸€ä¸ªé«˜é˜¶å‡½æ•° mapï¼šæ¥å—ä¸€ä¸ªå‡½æ•° fï¼ˆ`func (T1) T2`ï¼‰å’Œä¸€ä¸ªçº¿æ€§è¡¨ l1ï¼ˆ`[]T1`ï¼‰ï¼Œå¯¹ l1 ä¸­çš„æ¯ä¸ªå…ƒç´ åº”ç”¨å‡½æ•° fï¼Œè¿”å›çš„ç»“æœç»„æˆæ–°çš„çº¿æ€§è¡¨ l2ï¼ˆ`[]T2`ï¼‰

   å¦‚æœä½¿ç”¨ä»£ç ç”Ÿæˆçš„è¯ï¼Œä¸ºäº†é¿å…å‘½åå†²çªï¼Œæˆ‘ä»¬ä¸å¾—ä¸å†™å‡º `MapIntInt`ã€`MapIntUint`ã€`MapIntString` è¿™æ ·çš„å¥‡æ€ªåå­—ï¼Œè€Œä¸”ç”±äºç±»å‹çš„ç»„åˆï¼Œä»£ç ç”Ÿæˆçš„é‡å°†å¤§å¤§è†¨èƒ€ã€‚

   æˆ‘ä»¬å¯ä»¥å‘ç°åœ¨ç°æœ‰çš„æ”¯æŒ FP ç‰¹æ€§çš„ Go library é‡Œï¼š

   - æœ‰çš„ï¼ˆ hasgo__ ï¼‰é€‰æ‹©å°† map å®ç°æˆäº†é—­åˆè¿ç®—ï¼ˆ`[]T â†’ []T`ï¼‰ï¼Œç‰ºç‰²äº†è¡¨è¾¾èƒ½åŠ›
   - æœ‰çš„ï¼ˆ functional-go__ ï¼‰å¼ºè¡Œç”¨ä»£ç ç”Ÿæˆå¯¼è‡´æ¥å£æ•°ç›®çˆ†ç‚¸
   - æœ‰çš„ï¼ˆ fpGo__ ï¼‰é€‰æ‹©ç‰ºç‰²ç±»å‹å®‰å…¨ç”¨ interface{} å®ç°

   å¦‚æœä½¿ç”¨æ³›å‹çš„è¯ï¼Œåªéœ€è¦å®šä¹‰è¿™æ ·çš„ç­¾åå°±å¥½äº†::

      func Map[T1, T2 any](f func(T1) T2, src []T1) []T2

__ https://github.com/golang/go/search?q=filename%3Agen.go
__ https://pkg.go.dev/github.com/DylanMeeus/hasgo/types?utm_source=godoc#Ints.Map
__ https://pkg.go.dev/github.com/logic-building/functional-go/fp
__ https://pkg.go.dev/github.com/TeaEntityLab/fpGo#Map

æ— ç³–çš„æ³›å‹
----------

Go çš„è¯­æ³•åœ¨ä¸€ä¼—çš„ç¼–ç¨‹è¯­è¨€é‡Œç»å¯¹ç®—ä¸ä¸Šç®€æ´ä¼˜é›…ã€‚åœ¨å®˜ç½‘ä¸Šçœ‹åˆ°æ“ä½œ channel æ—¶ `<-` çš„ç›´è§‚ä¾¿æ·è®©ä½ å¿ƒä¸‹æš—å–œï¼Œè€Œä¸€æ—¦ä½ å¼€å§‹å†™ real world çš„ä»£ç ï¼Œè¿™ä¸ªè¯­è¨€å°±å¤„å¤„éš¾æ©è®¾è®¡ä¸Šçš„ç®€é™‹ã€‚æ³›å‹å³å°†åˆ°æ¥ï¼Œè€Œè¿™ä¸ªè¯­è¨€çš„å…¶ä»–éƒ¨åˆ†ä¼¼ä¹æ²¡æœ‰åšå¥½å‡†å¤‡ï¼š

é—­åŒ…è¯­æ³•
~~~~~~~~

åœ¨ Haskell ä¸­çš„åŒ¿åå‡½æ•°å½¢å¼éå¸¸ç®€æ´ï¼š

.. code:: haskell

   filter (\x -> x >= 0) [-2, -1, 0, 1, 2] 
   -- Output:
   -- [0,1,2]

è€Œåœ¨ Golang é‡Œï¼Œå‡½æ•°çš„ç±»å‹ç­¾åä¸å¯çœç•¥ï¼Œæ— è®ºé«˜é˜¶å‡½æ•°è¦æ±‚ä½•ç§ç­¾åï¼Œè°ƒç”¨è€…åœ¨æ„é€ é—­åŒ…çš„æ—¶å€™æ€»æ˜¯è¦å®Œå®Œæ•´æ•´åœ°å°†å…¶ç…§æŠ„ä¸€é [2]_ ::

   func foo(bar func(a int, b float64, c string) string) func() string {
           return func() string {
                   return bar(1, 1.0, "")
           }
   }

   func main() {
           foobar := foo(func(_ int, _ float64, c string) string {
                   return c
           })
           foobar()
   }

è¿™ä¸ªé—®é¢˜å¯ä»¥å½’ç»“äº Go å›¢é˜Ÿä¸ºäº†ä¿æŒæ‰€è°“çš„ã€Œå¤§é“è‡³ç®€ã€ï¼Œè€Œå¯¹ç±»å‹æ¨å¯¼è¿™æ ·æå‡æ•ˆç‡é™ä½å†—ä½™çš„ç‰¹æ€§çš„å¿½è§†ï¼ˆæ³›å‹çš„å§—å§—æ¥è¿Ÿåˆä½•å°ä¸æ˜¯å¦‚æ­¤å‘¢ï¼Ÿï¼‰ã€‚ `proposal: Go 2: Lightweight anonymous function syntax #21498`__ æå‡ºäº†ä¸€ä¸ªç®€åŒ–é—­åŒ…è°ƒç”¨è¯­æ³•çš„ææ¡ˆï¼Œä½†å³ä½¿è¯¥ææ¡ˆè¢« acceptï¼Œæˆ‘ä»¬æœ€å¿«ä¹Ÿåªèƒ½åœ¨ Go 2 é‡Œè§åˆ°å®ƒäº†ã€‚

__ https://github.com/golang/go/issues/21498

æ–¹æ³•ç±»å‹å‚æ•°
~~~~~~~~~~~~

:enwiki:`é“¾å¼è°ƒç”¨ <Method_chaining>` ï¼ˆMethod chainingï¼‰æ˜¯ä¸€ç§è°ƒç”¨å‡½æ•°çš„è¯­æ³•ï¼Œæ¯ä¸ªè°ƒç”¨éƒ½ä¼šè¿”å›ä¸€ä¸ªå¯¹è±¡ï¼Œç´§æ¥ç€åˆå¯ä»¥è°ƒç”¨è¯¥å¯¹è±¡å…³è”çš„æ–¹æ³•ï¼Œè¯¥æ–¹æ³•åŒæ ·ä¹Ÿè¿”å›ä¸€ä¸ªå¯¹è±¡ã€‚é“¾å¼è°ƒç”¨èƒ½æ˜¾è‘—åœ°æ¶ˆé™¤è°ƒç”¨çš„åµŒå¥—ï¼Œå¯è¯»æ€§å¥½ã€‚æˆ‘ä»¬ç†Ÿæ‚‰çš„ GORM çš„ API é‡Œå°±å¤§é‡ä½¿ç”¨äº†é“¾å¼è°ƒç”¨::

   db.Where("name = ?", "jinzhu").Where("age = ?", 18).First(&user)

åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­ï¼Œæ¯ä¸ªé«˜é˜¶å‡½æ•°å¾€å¾€åªå®ç°äº†ç®€å•çš„åŠŸèƒ½ï¼Œé€šè¿‡å®ƒä»¬çš„ç»„åˆå®ç°å¤æ‚çš„æ•°æ®æ“çºµã€‚

åœ¨æ— æ³•ä½¿ç”¨é“¾å¼è°ƒç”¨çš„æƒ…å†µä¸‹ï¼Œé«˜é˜¶å‡½æ•°çš„äº’ç›¸ç»„åˆæ˜¯è¿™æ ·å­çš„ï¼ˆè¿™ä»…ä»…æ˜¯ä¸¤å±‚çš„åµŒå¥—ï¼‰::

   Map(func(v int) int { return v + 1 },
      Filter(func(v int) bool { return v >= 0 },
         []int{-2, -1, -0, 1, 2}))

å¦‚æœç”¨é“¾å¼è°ƒç”¨å‘¢ï¼Ÿæˆ‘ä»¬ç»§ç»­æ²¿ç”¨å‰é¢çš„ filter ï¼Œæ”¹æˆä»¥ä¸‹å½¢å¼::

   type List[T any] []T

   func (l List[T]) Filter(f func(T) bool) List[T] {
           var dst []T
           for _, v := range l {
                   if f(v) {
                           dst = append(dst, v)
                   }
           }
           return List[T](dst)
   }

   func main() {
           l := List[int]([]int{-2, -1, -0, 1, 2}).
                   Filter(func(v int) bool { return v >= 0 }).
                   Filter(func(v int) bool { return v < 2 })
           fmt.Println(l)
   } 
   // Output:
   // [0 1]

çœ‹èµ·æ¥å¾ˆç¾å¥½ï¼Œä½†ä¸ºä»€ä¹ˆä¸ç”¨ map æ“ä½œä¸¾ä¾‹å‘¢ï¼Ÿæˆ‘ä»¬å¾ˆå®¹æ˜“å†™å‡ºè¿™æ ·çš„æ–¹æ³•ç­¾å::

   // INVALID CODE!!!
   func (l List[T1]) Map[T2 any](f func(T1) T2) List[T2]

å¾ˆé—æ†¾è¿™æ ·çš„ä»£ç æ˜¯æ²¡æ³•é€šè¿‡ç¼–è¯‘çš„ï¼Œæˆ‘ä»¬ä¼šè·å¾—ä»¥ä¸‹é”™è¯¯ï¼š

   invalid AST: method must have no type parameter

ææ¡ˆçš„ `#No parameterized methods`__ ä¸€èŠ‚æ˜ç¡®è¡¨ç¤ºäº†æ–¹æ³•ï¼ˆmethodï¼Œä¹Ÿå°±æ˜¯æœ‰ recevier çš„å‡½æ•°ï¼‰ä¸æ”¯æŒå•ç‹¬æŒ‡å®šç±»å‹å‚æ•°ï¼š

   This design does not permit methods to declare type parameters that are specific to the method. The receiver may have type parameters, but the method may not add any type parameters. [1]_

è¿™ä¸ªå†³å®šå®é™…ä¸Šæ˜¯ä¸ªä¸å¾—å·²çš„å¦¥åã€‚å‡è®¾æˆ‘ä»¬å®ç°äº†ä¸Šè¿°çš„æ–¹æ³•ï¼Œå°±æ„å‘³å¯¹äºä¸€ä¸ªå·²ç»å®ä¾‹åŒ–äº†çš„ `List[T]` å¯¹è±¡ï¼ˆæ¯”å¦‚è¯´ `List[int]`ï¼‰ï¼Œå®ƒçš„ `Map` æ–¹æ³•å¯èƒ½æœ‰å¤šä¸ªç‰ˆæœ¬ï¼š`Map(func (int) int) List[int]` æˆ–è€… `Map(func (int) string) List[string]`ï¼Œå½“ç”¨æˆ·çš„ä»£ç è°ƒç”¨å®ƒä»¬æ—¶ï¼Œå®ƒä»¬çš„ä»£ç å¿…ç„¶åœ¨ä¹‹å‰çš„æŸä¸ªæ—¶åˆ»ç”Ÿæˆäº†ï¼Œé‚£ä¹ˆåº”è¯¥åœ¨ä»€ä¹ˆæ—¶å€™å‘¢ï¼Ÿ

1. åœ¨ç¼–è¯‘æœŸï¼Œæ›´å‡†ç¡®åœ°è¯´ï¼Œåœ¨ç¼–è¯‘çš„ link é˜¶æ®µï¼Œè¿™éœ€è¦ linker å»éå†æ•´ä¸ª call graphï¼Œç¡®å®šç¨‹åºä¸­åˆ°åº•ä½¿ç”¨äº†å‡ ä¸ªç‰ˆæœ¬çš„ `Map`ã€‚é—®é¢˜åœ¨äºåå°„ï¼ˆreflectionï¼‰çš„å­˜åœ¨ï¼šç”¨æˆ·å¯ä»¥ç”¨ `reflect.MethodByName` åŠ¨æ€åœ°è°ƒç”¨å¯¹è±¡çš„æ–¹æ³•ï¼Œæ‰€ä»¥å³ä½¿éå†äº†æ•´ä¸ª call graphï¼Œæˆ‘ä»¬ä¹Ÿæ— æ³•ç¡®ä¿ç”¨æˆ·çš„ä»£ç åˆ°åº•è°ƒç”¨äº†å‡ ä¸ªç‰ˆæœ¬çš„ `Map`
2. åœ¨è¿è¡ŒæœŸï¼Œåœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨æ–¹æ³•æ—¶ yield åˆ° runtime ä¸­ï¼Œç”Ÿæˆå¯¹åº”ç‰ˆæœ¬çš„å‡½æ•°å resume å›å»ï¼Œè¿™è¦æ±‚ runtime æ”¯æŒ JITï¼ˆJust-in-time compilationï¼‰ï¼Œè€Œç›®å‰ Go å¹¶ä¸æ”¯æŒï¼Œå³ä½¿æœªæ¥ JIT çš„æ”¯æŒæä¸Šæ—¥ç¨‹ï¼Œè¿™ä¹Ÿä¸æ˜¯ä¸€è¹´è€Œå°±çš„äº‹æƒ…

ç»¼ä¸Šï¼ŒGo å›¢é˜Ÿé€‰æ‹©äº†ä¸æ”¯æŒç»™ method æŒ‡å®šç±»å‹å‚æ•°ï¼Œå®Œç¾äº†è§£å†³è¿™ä¸ªé—®é¢˜ ğŸ‰ã€‚

__ https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#No-parameterized-methods

æƒ°æ€§æ±‚å€¼
========

:zhwiki:`æƒ°æ€§æ±‚å€¼` ï¼ˆLazy Evaluationï¼‰æ˜¯å¦ä¸€ä¸ªé‡è¦çš„å‡½æ•°å¼ç‰¹æ€§ï¼Œä¸€ä¸ªä¸ä¸¥è°¨çš„æè¿°æ˜¯ï¼šåœ¨å®šä¹‰è¿ç®—æ—¶å€™ï¼Œè®¡ç®—ä¸ä¼šå‘ç”Ÿï¼Œç›´åˆ°æˆ‘ä»¬éœ€è¦è¿™ä¸ªå€¼çš„æ—¶å€™æ‰è¿›è¡Œã€‚å…¶ä¼˜ç‚¹åœ¨äºèƒ½ä½¿è®¡ç®—åœ¨ç©ºé—´å¤æ‚åº¦ä¸Šå¾—åˆ°æå¤§çš„ä¼˜åŒ–ã€‚ 

ä¸‹é¢çš„ä»£ç å±•ç¤ºäº†ä¸€ä¸ªå¹³å¹³æ— å¥‡çš„ Add å‡½æ•°å’Œå®ƒçš„ Lazy ç‰ˆæœ¬ï¼Œåè€…åœ¨ç»™å‡ºåŠ æ•°çš„æ—¶å€™ä¸ä¼šç«‹åˆ»è®¡ç®—ï¼Œè€Œæ˜¯è¿”å›ä¸€ä¸ªé—­åŒ…::

   func Add(a, b int) int {
           return a + b
   }

   func LazyAdd(a, b int) func() int {
           return func () int {
                   return a + b
           }
   }

ä¸Šé¢è¿™ä¸ªä¾‹å­æ²¡æœ‰ä½“ç°å‡ºæƒ°æ€§æ±‚å€¼èŠ‚çœç©ºé—´çš„ä¼˜ç‚¹ã€‚åŸºäºæˆ‘ä»¬ä¹‹å‰å®ç°çš„é«˜é˜¶å‡½æ•°ï¼Œåšä»¥ä¸‹çš„è¿ç®—::

   l := []int{-2, -1, -0, 1, 2}
   l = Filter(func(v int) bool { return v > -2 }, l)
   l = Filter(func(v int) bool { return v < 2 }, l)
   l = Filter(func(v int) bool { return v != 0 }, l)
   fmt.Println(l)

è®¡ç®—è¿‡ç¨‹ä¸­ä¼šäº§ç”Ÿ 3 ä¸ªæ–°çš„é•¿åº¦ä¸º 5 çš„ `[]int`ï¼Œç©ºé—´å¤æ‚åº¦ä¸º :math:`O(3 * N)`ï¼Œå°½ç®¡å¸¸æ•°åœ¨å¤æ‚åº¦åˆ†ææ—¶ç»å¸¸è¢«çœç•¥ï¼Œä½†åœ¨ç¨‹åºå®é™…è¿è¡Œçš„æ—¶å€™ï¼Œè¿™é‡Œçš„ 3 å°±æ„å‘³ç€ 3 å€çš„å†…å­˜å ç”¨ã€‚

å‡è®¾è¿™äº›é«˜é˜¶å‡½æ•°çš„æ±‚å€¼æ˜¯æƒ°æ€§çš„ï¼Œåˆ™è®¡ç®—åªä¼šåœ¨å¯¹ `fmt.Println` å¯¹å‚æ•°æ±‚å€¼çš„æ—¶å€™å‘ç”Ÿï¼Œå…ƒç´ ä»åŸå§‹çš„ `l` ä¸­è¢«å–å‡ºï¼Œåˆ¤æ–­ `if v > -2`ã€`if v < 2`ï¼Œæœ€åæ‰§è¡Œ `v + 1`ï¼Œæ”¾å…¥æ–°çš„ `[]int` ä¸­ï¼Œç©ºé—´å¤æ‚åº¦ä¾ç„¶æ˜¯ :math:`O(N)`ï¼Œä½†æ¯«æ— ç–‘é—®åœ°æˆ‘ä»¬åªä½¿ç”¨äº†ä¸€ä¸ª `[]int``ã€‚

æ³›å‹çš„å¼•å…¥å¯¹æƒ°æ€§æ±‚å€¼çš„å¥½å¤„æœ‰é™ï¼Œå¤§è‡´å’Œå‰æ–‡æ‰€è¿°ä¸€è‡´ï¼Œä½†è‡³å°‘æˆ‘ä»¬å¯ä»¥å®šä¹‰ç±»å‹é€šç”¨çš„ æ¥å£äº†::

   // ä¸€ä¸ªé€‚ç”¨äºçº¿æ€§ç»“æ„çš„è¿­ä»£å™¨æ¥å£
   type Iter[T any] interface{ Next() (T, bool) }

   // ç”¨äºå°†ä»»æ„ slice åŒ…è£…æˆ Iter[T]
   type SliceIter[T any] struct {
           i int
           s []T
   }

   func IterOfSlice[T any](s []T) Iter[T] {
           return &SliceIter[T]{s: s}
   }

   func (i *SliceIter[T]) Next() (v T, ok bool) {
           if ok = i.i < len(i.s); ok {
                   v = i.s[i.i]
                   i.i++
           }
           return
   }

æ¥ç€å®ç°æƒ°æ€§ç‰ˆæœ¬çš„ filter::

   type filterIter[T any] struct {
           f   func(T) bool
           src Iter[T]
   }

   func (i *filterIter[T]) Next() (v T, ok bool) {
           for {
                   v, ok = i.src.Next()
                   if !ok || i.f(v) {
                           return
                   }
           }
   }

   func Filter[T any](f func(T) bool, src Iter[T]) Iter[T] {
           return &filterIter[T]{f: f, src: src}
   }

å¯ä»¥çœ‹åˆ°è¿™ä¸ªç‰ˆæœ¬çš„ filter ä»…ä»…è¿”å›äº†ä¸€ä¸ª `Iter[T]`ï¼ˆ`*filterIter[T]`ï¼‰ï¼Œå®é™…çš„è¿ç®—åœ¨ `*filterIter[T].Next()` ä¸­è¿›è¡Œã€‚

æˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªå°† `Iter[T]` è½¬å› `[]T` çš„å‡½æ•°::

   func List[T any](src Iter[T]) (dst []T) {
           for {
                   v, ok := src.Next()
                   if !ok {
                           return
                   }
                   dst = append(dst, v)
           }
   }

æœ€åå®ç°ä¸€ä¸ªå’Œä¸Šé¢ç­‰ä»·çš„è¿ç®—ï¼Œä½†å®é™…çš„è®¡ç®—å·¥ä½œæ˜¯åœ¨ `List(i)` çš„è°ƒç”¨ä¸­å‘ç”Ÿçš„::

   i := IterOfSlice([]int{-2, -1, -0, 1, 2})
   i = Filter(func(v int) bool { return v > -2 }, i)
   i = Filter(func(v int) bool { return v < 2 }, i)
   i = Filter(func(v int) bool { return v != 0 }, i)
   fmt.Println(List(i))

Map çš„è¿­ä»£å™¨
------------

Golang ä¸­çš„ Hashmap `map[K]V` å’Œ Slice `[]T` ä¸€æ ·æ˜¯å¸¸ç”¨çš„æ•°æ®ç»“æ„ï¼Œå¦‚æœæˆ‘ä»¬èƒ½å°† map è½¬åŒ–ä¸ºä¸Šè¿°çš„ `Iter[T]`ï¼Œé‚£ä¹ˆ map å°±èƒ½ç›´æ¥ä½¿ç”¨å·²ç»å®ç°çš„å„ç§é«˜é˜¶å‡½æ•°ã€‚

`map[K]V` çš„è¿­ä»£åªèƒ½é€šè¿‡ `for ... range` è¿›è¡Œï¼Œæˆ‘ä»¬æ— æ³•é€šè¿‡å¸¸è§„çš„æ‰‹æ®µè·å¾—ä¸€ä¸ª iteratorã€‚åå°„å½“ç„¶å¯ä»¥åšåˆ°ï¼Œä½† `reflect.MapIter` å¤ªé‡äº†ã€‚:ghrepo:`modern-go/reflect2` æä¾›äº†ä¸€ä¸ª æ›´å¿«çš„å®ç°__ ï¼Œä½†å·²ç»è¶…å‡ºäº†æœ¬æ–‡çš„è®¨è®ºèŒƒå›´ï¼Œæ­¤å¤„ä¸å±•å¼€ï¼Œæœ‰å…´è¶£çš„æœ‹å‹å¯ä»¥è‡ªè¡Œç ”ç©¶ã€‚

__ https://pkg.go.dev/github.com/modern-go/reflect2#UnsafeMapIterator

å±€éƒ¨åº”ç”¨
========

:enwiki:`å±€éƒ¨åº”ç”¨ <Partial_application>` ï¼ˆPartial Applicationï¼‰æ˜¯ä¸€ç§å›ºå®šå¤šå‚å‡½æ•°çš„éƒ¨åˆ†å‚æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ªå¯ä»¥æ¥å—å‰©ä½™éƒ¨åˆ†å‚æ•°çš„å‡½æ•°çš„æ“ä½œã€‚

.. note:: å±€éƒ¨åº”ç”¨ä¸åŒäº :zhwiki:`æŸ¯é‡ŒåŒ–` ï¼ˆCurryingï¼‰ [4]_ ï¼ŒæŸ¯é‡ŒåŒ–æ˜¯ä¸€ç§ç”¨å¤šä¸ªå•å‚å‡½æ•°æ¥è¡¨ç¤ºå¤šå‚å‡½æ•°çš„æŠ€æœ¯ï¼Œåœ¨ Go å·²ç»æ”¯æŒå¤šå‚å‡½æ•°çš„æƒ…å†µä¸‹ï¼Œæœ¬æ–‡æš‚æ—¶ä¸è®¨è®º Currying çš„å®ç°ã€‚

æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæœ‰è¿”å›å€¼çš„æ¥æ”¶å•ä¸ªå‚æ•°çš„å‡½æ•°ç±»å‹::

   type FuncWith1Args[A, R any] func(A) R

å¯¹ä¸€ä¸ªåªæ¥å—ä¸€ä¸ªå‚æ•°çš„å‡½æ•°è¿›è¡Œä¸€æ¬¡ partial applicationï¼Œå…¶å®å°±ç›¸å½“äºæ±‚å€¼::

   func (f FuncWith1Args[A, R]) Partial(a A) R {
           return f(a)
   }

æ¥å—ä¸¤ä¸ªå‚æ•°çš„å‡½æ•°è¢« partial application åï¼Œä¸€ä¸ªå‚æ•°è¢«å›ºå®šï¼Œè‡ªç„¶è¿”å›ä¸€ä¸ªä¸Šè¿°çš„ `FuncWith1Args`::

   type FuncWith2Args[A1, A2, R any] func(A1, A2) R

   func (f FuncWith2Args[A1, A2, R]) Partial(a1 A1) FuncWith1Args[A2, R] {
           return func(a2 A2) R {
                   return f(a1, a2)
           }
   }

æˆ‘ä»¬æ¥è¯•ç”¨ä¸€ä¸‹ï¼Œå°†æˆ‘ä»¬ä¹‹å‰å®ç°çš„ filter åŒ…è£…æˆä¸€ä¸ª `FuncWith2Args`ï¼Œä»å·¦åˆ°å³å›ºå®šä¸¤ä¸ªå‚æ•°ï¼Œæœ€åå¾—åˆ°ç»“æœ::

   f2 := FuncWith2Args[func(int) bool, Iter[int], Iter[int]](Filter[int])
   f1 := f2.Partial(func(v int) bool { return v > -2 })
   r := f1.Partial(IterOfSlice([]int{-2, -1, -0, 1, 2}))
   fmt.Println(List(r)) 
   // Output:
   // [-1 0 1 2]

ç±»å‹å‚æ•°æ¨å¯¼
------------

æˆ‘ä»¬å‹‰å¼ºå®ç°äº† partial applicationï¼Œå¯æ˜¯æŠŠ `Filter` è½¬æ¢ä¸º `FuncWith2Args` çš„è¿‡ç¨‹å¤ªè¿‡ç¹çï¼Œåœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æŠŠç±»å‹å‚æ•°å®Œæ•´åœ°æŒ‡å®šäº†ä¸€éï¼Œæ˜¯ä¸æ˜¯é‡æ–°æ„Ÿå—åˆ°äº† é—­åŒ…è¯­æ³•_ å¸¦ç»™ä½ çš„æ— å¥ˆï¼Ÿ

è¿™ä¸€æ¬¡æˆ‘ä»¬å¹¶éæ— èƒ½ä¸ºåŠ›ï¼Œææ¡ˆä¸­çš„ `#Type inference`__ ä¸€èŠ‚æè¿°äº†å¯¹ç±»å‹å‚æ•°æ¨å¯¼çš„æ”¯æŒæƒ…å†µã€‚ä¸Šä¾‹çš„è½¬æ¢æ¯«æ— æ­§ä¹‰ï¼Œé‚£æˆ‘ä»¬æŠŠç±»å‹å‚æ•°å»æ‰::

   // INVALID CODE!!!
   f2 := FuncWith2Args(Filter[int])

ç¼–è¯‘å™¨å¦‚æ˜¯æŠ±æ€¨ï¼š

   cannot use generic type FuncWith2Args without instantiation

ææ¡ˆé‡Œçš„ç±»å‹å‚æ•°æ¨å¯¼ä»…é’ˆå¯¹å‡½æ•°è°ƒç”¨ï¼Œ`FuncWith2Args(XXX)` è™½ç„¶çœ‹èµ·æ¥åƒæ˜¯å‡½æ•°è°ƒç”¨è¯­æ³•ï¼Œä½†å…¶å®æ˜¯ä¸€ä¸ªç±»å‹çš„å®ä¾‹åŒ–ï¼Œé’ˆå¯¹ç±»å‹å®ä¾‹åŒ–çš„å‚æ•°ç±»å‹æ¨å¯¼ï¼ˆ `#Type inference for composite literals`__ ï¼‰è¿˜æ˜¯ä¸€ä¸ªå¾…å®šçš„ featureã€‚

å¦‚æœæˆ‘ä»¬å†™ä¸€ä¸ªå‡½æ•°æ¥å®ä¾‹åŒ–è¿™ä¸ªå¯¹è±¡å‘¢ï¼Ÿå¾ˆé—æ†¾ï¼Œåšä¸åˆ°ï¼šæˆ‘ä»¬ç”¨ä»€ä¹ˆè¡¨ç¤ºå…¥å‚å‘¢ï¼Ÿåªèƒ½å†™å‡ºè¿™æ ·ã€Œå¬å›ä¸€å¸­è¯ï¼Œå¦‚å¬ä¸€å¸­è¯ã€çš„å‡½æ•°::

   func Cast[A1, A2, R any](f FuncWith2Args[A1, A2, R]) FuncWith2Args[A1, A2, R] {
           return f
   }

ä½†æ˜¯å®ƒèƒ½å·¥ä½œï¼å½“æˆ‘ä»¬ç›´æ¥ä¼ å…¥ Filter çš„æ—¶å€™ï¼Œç¼–è¯‘å™¨ä¼šå¸®æˆ‘ä»¬éšå¼åœ°è½¬æ¢æˆä¸€ä¸ª `FuncWith2Args[func(int) bool, Iter[int], Iter[int]]`ï¼åŒæ—¶å› ä¸ºå‡½æ•°ç±»å‹å‚æ•°æ¨å¯¼çš„å­˜åœ¨ï¼Œæˆ‘ä»¬ä¸éœ€è¦æŒ‡å®šä»»ä½•çš„ç±»å‹å‚æ•°äº†::

   f2 := Cast(Filter[int])
   f1 := f2.Partial(func(v int) bool { return v > -2 })
   r := f1.Partial(IterOfSlice([]int{-2, -1, -0, 1, 2}))
   fmt.Println(List(r)) 
   // Output:
   // [-1 0 1 2]

__ https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#type-inference
__ https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#type-inference-for-composite-literals

å¯å˜ç±»å‹å‚æ•°
------------

`FuncWith1Args` ã€`FuncWith2Args` è¿™äº›åå­—è®©æˆ‘ä»¬æœ‰äº›ææƒšï¼Œä»¿ä½›å›åˆ°äº†ä»£ç ç”Ÿæˆçš„æ—¶ä»£ã€‚ä¸ºäº†å¤„ç†æ›´å¤šçš„å‚æ•°ï¼Œæˆ‘ä»¬è¿˜å¾—å†™ `FuncWith3Args`ã€`FuncWith4Args`â€¦ å—ï¼Ÿ

æ˜¯çš„ï¼Œ `#Omissions`__ ä¸€èŠ‚æåˆ°ï¼šGo çš„æ³›å‹ä¸æ”¯æŒå¯å˜æ•°ç›®çš„ç±»å‹å‚æ•°ï¼š

   No variadic type parameters. There is no support for variadic type parameters, which would permit writing a single generic function that takes different numbers of both type parameters and regular parameters.

å¯¹åº”åˆ°å‡½æ•°ç­¾åï¼Œæˆ‘ä»¬ä¹Ÿæ²¡æœ‰è¯­æ³•æ¥å£°æ˜æ‹¥æœ‰ä¸åŒç±»å‹çš„å¯å˜å‚æ•°ã€‚

__ https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#omissions

ç±»å‹ç³»ç»Ÿ
========

ä¼—å¤šå‡½æ•°å¼ç‰¹æ€§çš„å®ç°ä¾èµ–äºä¸€ä¸ªå¼ºå¤§ç±»å‹ç³»ç»Ÿï¼ŒGo çš„ç±»å‹ç³»ç»Ÿæ˜¾ç„¶ä¸è¶³ä»¥èƒœä»»ï¼Œä½œè€…ä¸æ˜¯ä¸“ä¸šäººå£«ï¼Œè¿™é‡Œæˆ‘ä»¬ä¸è®¨è®ºå…¶ä»–è¯­è¨€é‡Œè®©äººç¾¡æ…•çš„ç±»å‹ç±»ï¼ˆType Classï¼‰ã€ä»£æ•°æ•°æ®ç±»å‹ï¼ˆAlgebraic Data Typeï¼‰ï¼Œåªè®¨è®ºåœ¨ Go è¯­è¨€ä¸­å¼•å…¥æ³›å‹ä¹‹åï¼Œæˆ‘ä»¬çš„ç±»å‹ç³»ç»Ÿæœ‰å“ªäº›æ°´åœŸä¸æœçš„åœ°æ–¹ã€‚

.. hint:: å…¶å®ä¸Šæ–‡çš„å¤§éƒ¨åˆ†é—®é¢˜éƒ½å’Œç±»å‹ç³»ç»Ÿæ¯æ¯ç›¸å…³ï¼Œcase by case çš„è¯æˆ‘ä»¬å¯ä»¥åˆ—å‡ºéå¸¸å¤šçš„é—®é¢˜ï¼Œå› æ­¤ä»¥ä¸‹åªå±•ç¤ºæ˜æ˜¾ä¸åˆç†é‚£éƒ¨åˆ†ã€‚

ç¼–è¯‘æœŸç±»å‹åˆ¤æ–­
--------------

å½“æˆ‘ä»¬åœ¨å†™ä¸€æ®µæ³›å‹ä»£ç é‡Œçš„æ—¶å€™ï¼Œæœ‰æ—¶å€™ä¼šéœ€è¦æ ¹æ® `T` å®é™…ä¸Šçš„ç±»å‹å†³å®šæ¥ä¸‹æ¥çš„æµç¨‹ï¼Œå¯ Go çš„å®Œå…¨æ²¡æœ‰æä¾›åœ¨ç¼–è¯‘æœŸæ“ä½œç±»å‹çš„èƒ½åŠ›ã€‚è¿è¡ŒæœŸçš„ workaround å½“ç„¶æœ‰ï¼Œæ€ä¹ˆåšå‘¢ï¼šå°† `T` è½¬åŒ–ä¸º `interface{}`ï¼Œç„¶ååšä¸€æ¬¡ type assertion::

   func Foo[T any](n T) {
           if _, ok := (interface{})(n).(int); ok {
                   // do sth...
           }
   }

æ— æ³•è¾¨è®¤ã€ŒåŸºç¡€ç±»å‹ã€
--------------------

æˆ‘ä»¬åœ¨ ä»£ç ç”Ÿæˆä¹‹å›°_ æåˆ°è¿‡ï¼Œåœ¨ç±»å‹çº¦æŸä¸­å¯ä»¥ç”¨ `~T` çš„è¯­æ³•çº¦æŸæ‰€æœ‰ åŸºç¡€ç±»å‹ä¸º `T` çš„ç±»å‹ï¼Œè¿™æ˜¯ Go åœ¨è¯­æ³•å±‚é¢ä¸Šé¦–æ¬¡æš´éœ²å‡ºã€ŒåŸºç¡€ç±»å‹ã€çš„æ¦‚å¿µï¼Œåœ¨ä¹‹å‰æˆ‘ä»¬åªèƒ½é€šè¿‡ `reflect.(Value).Kind` è·å–ã€‚è€Œåœ¨ type assertion å’Œ type switch é‡Œå¹¶æ²¡æœ‰å¯¹åº”çš„è¯­æ³•å¤„ç†ã€ŒåŸºç¡€ç±»å‹ã€::

   type Int interface {
           ~int | ~uint
   }

   func IsSigned[T Int](n T) {
           switch (interface{})(n).(type) {
           case int:
                   fmt.Println("signed")
           default:
                   fmt.Println("unsigned")
           }
   }

   func main() {
           type MyInt int
           IsSigned(1)
           IsSigned(MyInt(1))
   } 
   // Output:
   // signed
   // unsigned

ä¹ä¸€çœ‹å¾ˆåˆç†ï¼Œ`MyInt` ç¡®å®ä¸æ˜¯ `int`ã€‚é‚£æˆ‘ä»¬è¦å¦‚ä½•åœ¨å‡½æ•°ä¸äº†è§£ `MyInt` çš„æƒ…å†µä¸‹æŠŠå®ƒå½“ `int` å¤„ç†å‘¢ï¼Ÿç­”æ¡ˆæ˜¯è¿˜ä¸èƒ½ï¼š `#Identifying the matched predeclared type`__ è¡¨ç¤ºè¿™æ˜¯ä¸ªæœªå†³çš„é—®é¢˜ï¼Œéœ€è¦åœ¨åç»­çš„ç‰ˆæœ¬ä¸­è®¨è®ºæ–°è¯­æ³•ã€‚æ€»ä¹‹ï¼Œåœ¨ 1.18 ä¸­ï¼Œæˆ‘ä»¬æ˜¯è§ä¸åˆ°å®ƒäº†ã€‚

__ https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#identifying-the-matched-predeclared-type

ç±»å‹çº¦æŸä¸å¯ç”¨äº type assertion
-------------------------------

ä¸€ä¸ªç›´è§‚çš„æƒ³æ³•æ˜¯å•ç‹¬å®šä¹‰ä¸€ä¸ª Signed çº¦æŸï¼Œç„¶ååˆ¤æ–­ T æ˜¯å¦æ»¡è¶³ Signed::

   type Signed interface {
           ~int
   }

   func IsSigned[T Int](n T) {
           if _, ok := (interface{})(n).(Signed); ok {
                   fmt.Println("signed")
           } else {
                   fmt.Println("unsigned")
           }
   }

ä½†å¾ˆå¯æƒœï¼Œç±»å‹çº¦æŸä¸èƒ½ç”¨äº type assertion/switchï¼Œç¼–è¯‘å™¨æŠ¥é”™å¦‚ä¸‹ï¼š

   interface contains type constraints

å°½ç®¡è®©ç±»å‹çº¦æŸç”¨äº type assertion å¯èƒ½ä¼šå¼•å…¥é¢å¤–çš„é—®é¢˜ï¼Œä½†ç‰ºç‰²è¿™ä¸ªæ”¯æŒè®© Go çš„ç±»å‹è¡¨è¾¾èƒ½åŠ›å¤§å¤§åœ°æ‰“äº†æŠ˜æ‰£ã€‚

æ€»ç»“
====

å‡½æ•°å¼ç¼–ç¨‹çš„ç‰¹æ€§ä¸æ­¢äºæ­¤ï¼Œä»£æ•°æ•°æ®ç±»å‹ã€å¼•ç”¨é€æ˜ï¼ˆReferential Transparencyï¼‰ç­‰åœ¨æœ¬æ–‡ä¸­éƒ½æœªèƒ½è¦†ç›–åˆ°ã€‚
æ€»å¾—æ¥è¯´ï¼ŒGo æ³›å‹çš„å¼•å…¥ï¼š

1. ä½¿çš„éƒ¨åˆ† *å‡½æ•°å¼ç‰¹æ€§èƒ½ä»¥æ›´é€šç”¨çš„æ–¹å¼è¢«å®ç°*
2. *çµæ´»åº¦æ¯”ä»£ç ç”Ÿæˆæ›´é«˜* ï¼Œç”¨æ³•æ›´è‡ªç„¶ï¼Œä½†ç»†èŠ‚ä¸Šçš„å°é—®é¢˜å¾ˆå¤š
3. 1.18 çš„æ³›å‹åœ¨å¼•å…¥ type paramters è¯­æ³•ä¹‹å¤–å¹¶æ²¡æœ‰å…¶ä»–å¤§åˆ€é˜”æ–§çš„æ”¹å˜ï¼Œå¯¼è‡´æ³›å‹å’Œè¿™ä¸ªè¯­è¨€çš„å…¶ä»–éƒ¨åˆ†æ˜¾å¾—æœ‰äº›æ ¼æ ¼ä¸å…¥ï¼Œä¹Ÿä½¿å¾—æ³›å‹çš„èƒ½åŠ›å—é™ã€‚ *è‡³å°‘åœ¨ 1.18 é‡Œï¼Œæˆ‘ä»¬è¦å¿å—æ³›å‹ä¸­å­˜åœ¨çš„ç§ç§ä¸ä¸€è‡´*
4. å—åˆ¶äº Go ç±»å‹ç³»ç»Ÿçš„è¡¨è¾¾èƒ½åŠ›ï¼Œæˆ‘ä»¬æ— æ³•è¡¨ç¤ºå¤æ‚çš„ç±»å‹çº¦æŸï¼Œè‡ªç„¶ä¹Ÿ *æ— æ³•å®ç°å®Œå¤‡çš„å‡½æ•°å¼ç‰¹æ€§*

å‚è€ƒ
====

.. [1] `Type Parameters Proposal`__
.. [2] `Golang å‡½æ•°å¼ç¼–ç¨‹ç®€è¿°`__
.. [3] `GopherCon 2020: Dylan Meeus - Functional Programming with Go`__
.. [4] `Partial Function Application is not Currying`__

__ https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md
__ https://hedzr.com/golang/fp/golang-functional-programming-in-brief/
__ https://www.youtube.com/watch?v=wqs8n5Uk5OM
__ https://www.uncarved.com/articles/not-currying/
